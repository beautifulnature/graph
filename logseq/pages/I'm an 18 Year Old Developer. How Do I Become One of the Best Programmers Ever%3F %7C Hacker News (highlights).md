title:: I'm an 18 Year Old Developer. How Do I Become One of the Best Programmers Ever? | Hacker News (highlights)
author:: [[news.ycombinator.com]]
full-title:: "I'm an 18 Year Old Developer. How Do I Become One of the Best Programmers Ever? | Hacker News"
category:: #articles
url:: https://news.ycombinator.com/item?id=32589714
tags:: #[[programming]]

- Highlights first synced by [[Readwise]] [[Feb 20th, 2023]]
	- Don't compare yourselves to others, compare yourself to your past self. Comparisons to others will either make you think poorly of yourself or make you think poorly of others.
	  Some general tips that I've found useful to make myself better:
	- Unless your IQ is above 140 you stand no chance. The world has a lot of very smart people and it would be better for your mental health to make peace with the fact that you are probably just above average on the bell curve and that you are not anything special. You're not a beautiful and unique snowflake. You're the same decaying organic matter as everything else. We're all part of the same compost heap. We're all singing, all dancing crap of the world.
	- Many moons ago I read a story on HN about a very successful programmer that was at the top of his field. He co founded a famous software company and his talent grew and grew until something strange happened. After achieving his greatest feats of engineering he suddenly, quite unexpectantly to everyone lost total interest in his art. He also lost interest in his partner. It was discovered that he had a rare kind of brain disease. The family was like a survivors group for a living person. He was young if I recall.
	  I don't mean to scare you but you are definitely smart enough to do what he did given the right environment and it looks like you are there. Unlike your peers learning is not a chore but it is exhilarating.
	  But remember we are finite, we have an experation date. Groups of people study us and determine when that date is and sell us life insurance.
	  Keep in mind that not all roads lead to happiness. You could have great riches, fame, respect, admiration. But it is all for nothing if there is no love.
	  For some love is in craft but craft cannot love you back.
	  Others find love in a mate and it is a rare couple that is happy. But that doesn't mean it isn't worth it to keep an eye for one that you like. If you find one that sees you as a partner, even if she isn't easy on the eyes, will give you a payback that is hard to measure. Family, inter-family fun. Vacation with meaning.
	  There is the final love that no one can take from you and that is your connection to the Almighty creator. His voice is a whisper. But it speaks love.
	- Advice? Don’t push yourself as far as possible. You’re young, talented, and capable of kicking ass. Spread that ass kicking out over your lifetime and make sure you don’t burn out early.
	  Assuming you’re on the west coast, it’s 10 PM. Take a break and relax.
	- Here's some concrete advice from someone ~3x your age who started programming at about the same time.
	  1. Keep at least one project going just for the fun of it. Remember the joy you've found in programming, and never lose it. A friend of mine is reverse-engineering the Civ IV AI so he can write mods for it. This will not make him famous or wealthy, but serves as something to look forward to when he's not pumping for The Man.
	  2. Stay in good shape physically. _Mens sana in corpore sano_ and all that. Your body is not just a dumb flesh robot that carries your brain around -- and even if it were, that enough is good reason to keep it healthy.
	  3. Learn to work with people remotely on important things. Find interesting or useful open source projects and contribute to them. The technical aspects will be easier than the social ones, likely. These are important skills. Vanishingly little non-trivial software is made by one person.
	  4. Keep learning programming languages. Software engineering is a discipline abstract from its tools. The more languages you learn the more approaches you will have to problems. E.g., learn lisp -- it'll permanently rewire parts of your brain.
	- powlow 3 days ago | prev | next [–]
	  
	  I'm in my late 30s and worked with an absolutely brilliant 18 year old who exceeded all of us oldies with his raw talent.
	  He had passion projects outside of work that were already popular within our technical niche when we hired him, and continued to deliver on these, very impressively!
	  We had him present at an international conference on some of the work he'd done for us, which really helped with his growth - it was very different from his other skill sets but he did an excellent job too.
	  But I think to be honest, the biggest change in his life was finding a romantic partner. Perhaps it was this, perhaps it was just maturing anyway, but he seemed to gain a lot of confidence and wellbeing. She certainly enriched his life in a way that the technical work didn't.
	  So my advice to you would be:
	- Work on the hardest problems you can with the smartest people you know. Keep that up long enough and you'll be all on your own, with some crackpot idea nobody is really sure if it will work or not. That's when you've met the cutting edge, the boundary of what anyone knows or has done. At that point you just keep on exploring. Hack something important and useful together, and invent it into the world. Don't worry about the laurels, they'll come in due time.
	  If there was a book called "How to Become the Greatest Programmer Ever" I would recommend it to you. The fact of the matter is the world is a strange and lonely place: Your guess is as good as mine. Follow the well marked paths as long as you can, never let good advice fall on deaf ears, and pray to heaven for guidance when the going gets tough
	- You’re gonna have to give up a lot, like the girl you love, when she takes too much of your time or doesn’t understand what you’re trying to do. You’ll get over it. But sometimes sacrificing everything will actually break you so learn how to recognize that. If you make a mistake there then recover and move on, like always.
	  The companies you’re working at are shit and web dev is easy, try to get through that phase in the next year. There are unlimited loopholes for making money, pick one and extract from the world what you need to live, then get back to doing deep and difficult programming. Learn a lot of pure mathematics, because easy programming like web dev will become commoditized or automated and you need the mental flexibility given by pure math in order to come out on top in the future. You have to think longer term than you are now.
	  And living is an art, refine and trust your intuition constantly. Every ideology and group is wrong in some way. You have to be outside all of them and also take what they know.
	  Recognize when you’re fighting yourself and realize that you’re distracted. Probably by status or money or ego things. Accept the lost time and move on.
	  Regularly put everything on the line. You have no time to waste being risk-averse. Make really big bets and make sure they succeed. If they don’t then hopefully you’re fine physically and worst case you have nothing and go live in the woods and eat rice and beans and plot the next move. This is fine, you’ll learn to deal with catastrophic failure. That means you’re pushing the limits. Push harder.
	- Go fly a kite.
	  Programmers who only do programming, suck at programming. You can't get perspective by sitting still. You have to expose yourself to new things.
	  Learn how to sail. Take up stamp collecting. Grow exotic flowers in teacups. Earn a black belt. Become a baker. Go to a lindy hop dance night on the weekend. Take apart and put together an engine. Learn a new language. Travel the world.
	  After all that, programming will seem like a walk in the park. You'll probably get bored with it, honestly. Computer science is a pretty limited field and has had minor incremental improvements over the past two decades. Hardware stuff gets more advanced but the software is mostly the same as 30 years ago. Still, outside experiences will help inform your perspective on what works and what doesn't, where the sides of the box are. Aside from that, just practice a lot, in a lot of different fields.
	  Also, please don't make the mistake of trying to prove yourself through achievements. We would all much rather work with the best person in the world than the best programmer.
	- I've seen many...so this is my advice...increase your output in software. Breed your software development especially opensource in public repositories like rabbits. Design your own programming language something like Lua scripting which is much easier to achieve wide usage than compiled one like Julia or Rust. Choose a field say AI and go real deep into it. Then you can also built your software output around it. Be shameless promoting your own...be as shameless as like Andrew Tate. Dont worry getting into FAMNG. When you're polific they will headhunt you. Focus on your output...everything elese like being the best and 10x 100x will automatically follows. Avoid hacking/cracking that is a dark path that you will be a great sith but rarely will the general public/compabies appreciate/reward you.
	- Quit the industry and go into academia. Professional programming is slow and rarely innovative.
	  Go forward with a PhD and post-doc, and do research on solving climate change via computers. Win a Turing award for groundbreaking language and ISA based around energy efficiency of computation. Congratulations, you are now one of the best programmers.
	- A high-dimensional ball has more surface area than volume.
	  Human brains are only used to thinking in lower dimensional spaces but human lives intrinsically occupy manyfold dimensional spaces.
	  "Better" is only a meaningful metric under two circumstances:
	  * A one dimensional ordering, in which case all items can be ordered in relation with each other
	  * A multi-dimensional ordering in which one item has total domination over an another item
	  Take recipes for example, recipes can be evaluated based on taste, nutrition, ease of preparation, quality of writing, availability of ingredients etc, etc, etc.
	  Is a recipe that's easier to make but less tasty "worse" than one that takes way more time but tastes way better? Either you can "linearize" the dimensions by assigning some kind of weighting like 0.5 * taste + 0.3 * easiness + 0.1 * nutrition + 0.1 * other OR you can accept there is no intrinsic ranking and say neither recipe is better than the other, they're just different.
	  But what you can say is that a recipe that is worse in taste AND worse in ease of preparation AND worse in nutrition AND worse at everything else is a categorically worse recipe. That's a recipe that's at the center of the ball and not the surface.
	  In a high-dimensional world, being the best is trivial, almost everyone is the best except the people who are all around mediocre, people who occupy the center of the ball.
	  Despite this, most people fail at this task, just like how most recipes you find on the internet are categorically not the best, because their mindset does not unlock this view of the world. They're followers rather than leaders and so they subscribe to a very narrow and rigid view of what programming means and are desperately competing amongst those dimensions with every other person who subscribes to that view and they never reach close to the top because a low dimensional ball has very little surface area relative to volume.
	  So if there's one single piece of advice I could give you about how to become "the best", it's to forge your own path early and confidently and bravely. There are a million different roles that programmers have in society that each require a million different types of skills and the one you're going to be the best at likely hasn't been discovered yet. Follow your passions and your interests and develop a unique point of view and thrive in the intersection between areas of rare overlap and becoming the best is simply table stakes.
	  Whatever you do, don't linearalize your life upon metrics given to you by someone else because they have an agenda to corrall you into a competition for their benefit, not yours. Introspect and figure out what "best" means for you and use that to drive you and you truly will believe you are the best because nobody else will share that same linearization as you.
	  For a very similar take on this, but from the Physics world, I recommend you read this paper: Physics in a diverse world or A Spherical Cow Model of Physics Talent [1]
	  [1] https://arxiv.org/abs/2203.09485
	- At 35, I have the same goal and feel that I've actually made quite a bit of progress and am working on some very interesting projects. I'll share some of my secrets with you:
	  1. When you find an issue in code, search the entire codebase for it because it's probable that the mistake has been made before. For example, I once used strncpy instead of strncpy_s which got flagged in the code review. After I learned why I searched the codebase and I had done that several times before that hadn't been caught in code reviews. I could have made my week easier by not doing this, as fixing the codebase resulted in additional time, more code reviews, and more embarrassment that I made a stupid mistake many times before my team noticed. However, if I hadn't, then we could have had customers experience issues in the future, which would have been far worse.
	  2. With any project, build out an extensive structure of resources personally curated by yourself. Get used to documenting everything you learn, even if it is just notes to yourself, but the more the better. At my job, in my file storage area, I have a folder for documentation, a folder for tests to run, a folder for things to install to set the tests up, a folder for customer cases, a folder for freeware that I use, etc. I'm constantly building these out the best I can. Make sure that it's an area you have complete control over so that you can control the organization of it.
	  3. Keep track of the issues that make it out to the public, even once they are fixed it takes customers years to update so you will be hearing a lot about any issue that gets out. My team recently changed a lot, so after the dust settled I asked for a few months to do some research. I used a lot of that time to build two spreadsheets. The first is a list of every customer case that was resolved, whether the issue was on their end (environmental) or on ours, and what the issue was. The second spreadsheet was a list of issues on our end, what versions they were introduced in, what versions and changesets they were fixed in, what to look for in the logs to detect the issue, and so on. I put these files in my folder for customer cases. Then, I used the info I gathered to create a script to scan logs, look for lines of interest, and output that a probable issue has been detected.
	  4. Realize that other people aren't going to do these things, even if they are good developers. I've become one of the core programmers and have survived multiple layoffs. My section of resources, my logging scanner, my issue spreadsheets, they are all out in areas publicly accessible to the other devs and it doesn't matter. I'm not afraid of becoming redundant and being replaced because my knowledge is out there. Rather, it's the exact opposite. The rest of my team, even though they are skilled programmers, are not going to do the same things that I do even if I explain all the details to them on how to keep track of everything. Instead, they are constantly amazed that I can often solve issues that pop up immediately.
	  5. If someone finds a tool too complicated or confusing, then the issue is not with the person, but with the tool. Often as developers we are responsible for how tools are presented and explained but not who the user is. As such, it is tempting to say that the problem isn't with the tool we built, but with the "stupid" user. I call this view "Linux mentality" because I find many (of course not all) Linux users have a "git good" type attitude where they think the solution is for people to spend a vast amount of time and effort learning to use clunky tools, instead of finding better tools.
	  My favorite example of this came from this very forum: a comment on a post once actually said that if you don't know how to use the command line, then you have an "extreme addiction to IDEs", are "dumber by the day", and "you will be replaced by lesser skilled cheap labor inevitably". He never once thought that maybe the command line should be replaced with something better. The other example I have of this is in school when I was telling a classmate about software that I had written. He asked me why I had written it as anyone could write a script to do what I was doing. I told him that while he could write a script, my mom sure couldn't. In other words, I view complicated tools as an opportunity to either fix the tool or to write my own competing tool instead of expecting users to spend their precious time and effort overcoming the complications.
	  6. So far this has all been about working with people, which is the often overlooked part of programming. However, I have a secret about code as well: programming is a broken mess because it is over-complicated. Just like my last point was that complicated tools need to be fixed to be simpler, all of programming is complicated and should be simpler. At the end of the day, programming is just about defining functions and datatypes. Classes, constructors, destructors, exceptions, many of these things started out as ways to make programming easier but try to teach programming to a newbie and you'll see just how much of what we think is fundamental to programming is hard to explain why we do them.
	  In particular, the crux of my hot take is that I think Object Oriented Programming (OOP) is a mistake and a dead end. I'm not saying that you shouldn't use it. I'm saying that I think the jump from Procedural programming to more organized code made a mistake by going to OOP. Many people don't even realize what a class actually is: a grouping of a user defined datatype and a set of functions that invisibly take a variable of that datatype as its first parameter (Python in particular makes this more apparent by turning the invisible first parameter into a visible parameter named self). I have my own ideas about what programming should be instead of OOP, but its going to be a few more years before I'm ready to talk about it publicly, so I'll just leave this as a little teaser: both OOP and functional programming over complicate the ideas of programming and turn the entire field into a giant mess that takes years and decades to learn. I think they have missed the mark, and that there are other ways to fix the problems that procedural programming has. Until then though, it's probably still best to use OOP, but in the meantime, make sure you understand what a class actually is.
	- For best programmer that might be to learn more Data Structures and Algorithms. Maybe try some LeetCode. See if you can find a senior programmer to be your mentor.
	  For best developer, I think it is good to learn a bit about each team member's role. Learn some UX design, Scrum Master, Tester, Product Owner and Database Admin. You don’t need to learn enough to be able to do their job but enough to understand how and what they work with.
	  Keep learning programming, more languages, you come from the web, learn some Golang, Rust, Elixir, Python, to learn different paradigms. Do some side projects about things that you are passionate about (I play Dungeons & Dragons so I have built tools and websites to help with that).
	  Maybe get a job at a consultancy, you get to work with different clients in different domains and learn a lot.
	  But as others have pointed out, don’t burn yourself out. It sucks and takes a long time to come back from. Godspeed